(defun Flatten (X)
    (cond ((null X) nil)
          ((atom X)(cons X ()))
          (t (append (Flatten (car X))
                     (Flatten (cdr X)) ))
          ))
(defun fun11 (l1 l2)(fun22 l1 l2 nil))
(defun fun22 (l1 l2 res)
    (cond ( (null l1) res)
          ( (null l2) l1)
          ( (null (cdr l1)) (myfl (fun2 (car l1) l2 res) ) )
          ( t (fun22 (cdr l1) l2 (myfl (fun2 (car l1) l2 res))))
          ))
(defun fun2 (x l res)
    (interactive)
    (cond ( (null l) res)
          ( (null (cdr l)) (cond ( (atom x)  (cons (list x   (car l)) res ) )
                                 ( (listp x) (cons (cons (car l) x) res ) )
                                 ))
          ( t (fun2 x (cdr l) ( cond ( (atom x)  (cons (list x   (car l)) res ) )
                                     ( (listp x) (cons (cons (car l) x) res ) )
                                     )))
          ))
(defun myfl (l)
    (cond ( (null l) nil)
          ( (null (cdr l)) (list (Flatten  (car l) )))
          ( t (cons (Flatten (car l)) (myfl (cdr l))  ))
          ))

(defun fun3311 (l) (fun33 l nil nil))
(defun fun33(l res1 res2) ;;у нас появится список списков , эту функцию надо и использовать с самого начала так как количество конънкциий в дизъюнкции может быть большое,
    ;; то есть мб вариант (( x y z) V ( x2 y2 z2) V (x3 y3 z3)... )итд. А эта фунция отщипляет от списка первый список(то бишь первую & ) и второй список и потом
    ;;расскрывает скрбки и далее рекурсия с хвостом.
    (cond ( (null l) res2)
          ( (null (cddr l))  (fun33 nil (fun22 (car l) (cadr l) res1)  (cons (fun22 (car l) (cadr l) res1) res2 )))
          (defun find (l res)
              (cond ( (null l) res)
                    ( (null (cddr l)) (find1 (unlist2 (list (caaar l) (caadar l)) (cadr l) )))
                    ( t (mapcar 'find1 (unlist2 (list (caaar l) (caadar l)) (cdr l))))))
