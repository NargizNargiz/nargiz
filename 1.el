;;hmw
;;59-60 2 3 6 8
;;n1
(defun removelast(x)
    (interactive)
    (cond ((null x) nil)
          ((null (cdr x)) nil)
          (t (cons (car x) (removelast(cdr x))))))
(removelast '(1 2 3 4))
(removelast '(1 (2 3 4) 3323 32 dsf (213) (2 (3) () ) () ))
;;n2
(defun onelevel(x)
    (cond ((null x) t)
          ((null (cdr x)) (not (listp (car x))))
          ((not (listp(car x))) (onelevel (cdr x)))))
(onelevel '(d c d d d))
(onelevel '(a (sd) d d ))
;;n3
(defun bubl (n a)
    (cond ( (= n 0) nil)
          ( (= n 1) (cons a ()))
          ( t (cons (bubl (- n 1) a) () ))
          )
    )
(bubl 3 5)
;;n4
(defun lastatom(x)
    (cond ( (null x)  nil)
          ( (and (null (cdr x)) (listp (car x))) (lastatom (car x)))
          ( (null (cdr x)) (car x) )
          (t (lastatom (cdr x)))
          ))
(lastatom '( '( '(5) a b b ( a b )   ) ) )
(listp '(1))
;;n5 a)
(member 'a '(1 2 3 a))
(/= (length '(1 2 3)) (length '(3)) )

(defun eq_mn(l1 l2)
    )
(eq_mn '(1 2 3) '(1 3 2 333))
(defun delete(x l);;оставить одно повторение
    (cond ( (null l) nil )
          ( (listp x) (cond ((and (null (intersect l1 )) (null (intersect l2)))  )
                            )
            )
          ))
(defun intersect1 (l1 l2) (intersect l1 l2 nil))
(defun intersect ( x y res);;разность множеств
    (cond ( (null x) res)
          ( (null y) res)
          ( (null (cdr x)) (cond ((atom (car x)) (cond ((not (member (car x) y)) (cons (car x) res))
                                                       )
                                  (t (my_member (car x) y))))
            )
          (t (intersect (cdr x) y (cons (car x) res)) )
          ))

(defun set-eq (set1 set2)
    (cond ((and (null set1)
                (null set2)) t)
          ((atom (car set1)) (cond  ((member (car set1) set2) (set-eq (cdr set1) (remove (car set1) set2)))))
          (t nil)))
(defun abs (x)
    (cond ( (null x) nil)
          ( (atom x)(cond ((< x 0 ) (- 0 x) )
                          (t x))
            )))
(my_not 0)
(defun che(x)(abs (- (+ x 1) 2)) )
(set-eq '(1 2 3) '(3 2 1))
(set-eq '(w 1) '( 1 w))
(set-eq '(y 1) (list (che 0) 'y))
(set-eq '(1 2 3) '(3 2 7))

(and (null (intersect l1 )) (null (intersect l2)))
(member '(x 0) '(( 0 x) (w e) (o p)))
(intersect1 '(( 0 x) (w e) (o p)) '(0 x))
(intersect1 '((x 0) ( o p) (w e )) '(( 0 x) (w e) (o p)) )
(intersect1' ((0 x) ( w e)) '( x 0))
(equal 1 3 )
(append () '(1 2 3))
;;n6
(defun Remove2L(L)
    (cond  ( (null L) nil )
           ( (null(cdr L)) L)
           ( t        (cons (car L) (Remove2L(cddr L)) ) )
           )
    )
(Remove2L '(1 2 3 4 5 6 7 8))
(Remove2L '(1 2 3 4 5 4))
;;n4
(defun lastatom(x)
    (cond ( )

          )

    )
;;n8
(defun Mix1(x y)
    (interactive)
    (cond ( (null x) y)
          ( (null y) x)
          ( (and (null (cdr x)) (null(cdr y))) (append x y ))
          (t( cons (car x) (cons (car y) (Mix1 (cdr x) (cdr y)))))
          ))

(Mix1 '(c s g r y) '(2 1 3 44 55 66 77))
(Mix1 '(3 4) '(a b c))

(list '(1 2 3) 3 '(1 2 3))
(cons 1 '(5 5 5 43) )
(append '(1 w 3 e) '( 1 2 3 4))

;;n11
(defun position (x l)
    (cond ( (null x) 0)
          ( (equal x (car l)) 1)
          ( t (+ 1 (position x (cdr l))))
          ))
(position 1 '(2 2 3 1 5))
;;n13
(defun rightbr (l)
    (cond ( (null l) nil)
          ( (null (cdr l)) (cons l ()))
          ( t (cons (car l) (cons (rightbr (cdr l)) () ) ))
          ))
(rightbr '(a b c d))


(defun SubList(L1 L2)
    (cond((null L2) nil)
         ((SubL L1 L2))
         (t (SubList L1 (cdr L2)))))
(defun leftbr (l)
    (cond ( (null l) nil)
          ( (null(cdr l))  l )
          ( t (cons (cons (car l) () ) (leftbr (cdr l)) ))))

(leftbr '(1 2 3 4 5))
(cons '(1 4 5) '(3 3 ))

(defun SubL(L1 L2)
    (cond((null L1) t)
         ((null L2) nil)
         ((eql (car L1)(car L2))
          (SubL (cdr L1)(cdr L2)))))

(SubList '( a b) '( s d f a b d d))
(Remove2L '(1 2 3 4 5 6 7 8))
